"use strict";const _eta=require("eta");const _path=require("path");const _promises=require("fs/promises");const _portal=require("./portal");const _dotenv=require("dotenv");const _util=require("./util");_dotenv.config();const ENDPOINT=process.env.ENDPOINT;process.env.TZ="Asia/Tokyo";const eta=new _eta.Eta({views:_path.join(__dirname,"views")});const isKaisaiIds=arg=>{if("jra"in arg&&"nar"in arg){if(Array.isArray(arg.jra)&&Array.isArray(arg.nar)){return true}}return false};const isRaceDetail=arg=>{if(!isObject(arg)){return false}if("race_id"in arg&&"org"in arg&&"metadata"in arg&&"entries"in arg){return true}return false};const isObject=arg=>{return arg instanceof Object&&!(arg instanceof Array)?true:false};const isResultData=arg=>{if("rank"in arg&&"time"in arg&&"diff"in arg&&"rank_at_corner"in arg&&"max_speed"in arg&&"owner_id"in arg&&"owner_name"in arg&&"bounty"in arg){return true}return false};const isHorseRecord=arg=>{if("horse_id"in arg&&"results"in arg){return true}return false};const main=async()=>{const yyyymmdd=getCurrentDate();const kaisai=await getKaisaiList(yyyymmdd);const races_jra=await parallelizedProcess(kaisai,"jra");const races_nar=await parallelizedProcess(kaisai,"nar");const races_all=races_jra.concat(races_nar);await (0,_portal.default)(yyyymmdd,races_all);return};const getCurrentDate=()=>{process.env.TZ="Asia/Tokyo";const currentDate=new Date;const year=currentDate.getFullYear();const month=String(currentDate.getMonth()+1).padStart(2,"0");const day=String(currentDate.getDate()).padStart(2,"0");return`${year}${month}${day}`};const getKaisaiList=async yyyymmdd=>{const entrypoint="getKaisaiList";const url=`${ENDPOINT}/${entrypoint}`;const query=new URLSearchParams({dt:yyyymmdd,key:process.env.API_KEY});const response=await fetch(`${url}?${query}`);const data=await response.json();if(isKaisaiIds(data)){return data}else{throw new Error("[getKaisaiList] Invalid value is returned from server."+"Check that the vars `url` and `query` are set to the correct values.")}};const parallelizedProcess=async(kaisai,org)=>{const results=await Promise.allSettled(kaisai[org].map(race_id=>fetchDataAndRenderMarkdown(race_id,org)));return results.map(res=>res.status==="fulfilled"?res.value:false).filter(isRaceDetail)};const fetchDataAndRenderMarkdown=async(race_id,org)=>{const race_detail=await getRaceDetail(race_id,org);await renderToMarkdown(race_detail);return race_detail};const getRaceDetail=async(race_id,org)=>{const entrypoint="getRaceDetail";const url=`${ENDPOINT}/${entrypoint}`;const query=new URLSearchParams({race_id,org,key:process.env.API_KEY});const response=await fetch(`${url}?${query}`);const data=await response.json();if(isRaceDetail(data)){return data}else{throw new Error("[getRaceDetail] Invalid value is returned from server."+"Check that the vars `url` and `query` are set to the correct values.")}};const renderToMarkdown=async race_detail=>{const{race_id,org,metadata,entries}=race_detail;const{name:title}=metadata;const{R,direction,distance,regulation,schedule,track,timestamp}=metadata;const R_i=R.padStart(2,"0");const place=schedule.replace(/\d+回*/i,"").replace(/\d+(日目)*/i,"");const start_time=timestamp.split(/\s/).pop().slice(0,5);const description=`発走時刻 ${start_time} ${track} ${direction} ${distance}m`;const promised_records=await Promise.allSettled(entries.map(entry=>getRecordsFromPreviousResult(entry.horse_id,timestamp)));const records=promised_records.map(res=>res.status==="fulfilled"?res.value:false).filter(isHorseRecord);const props={title:`${title}【R${R_i}】`,records,distance,description:regulation.length!==0?`${description} 〈${regulation}〉`:description,frontmatter:{page_id:race_id,page_title:`【R${R_i}】${title}【${place}】`,pagination_label:`【${place}R${R_i}】${title}`,sidebar_label:title,date:timestamp.split(/\s+/).shift(),keywords:[`${place}競馬`,"データ分析"],description:`【R${R_i}】 ${description} 【${place}】`,thumbnail:"https://example.com/image.png",slug:R_i,tags:[place,`R${R_i}`,`${track}${direction}${distance}m`,regulation]},entries,date_today:timestamp.split(/\s+/).shift()};const rendered_text=await eta.renderAsync("./each_race/template",props);const place_code=race_id.slice(4,6);const filepath=(0,_util.makeFilepath)(race_id,timestamp,place_code);try{await (0,_promises.mkdir)(_path.dirname(filepath),{recursive:true});await (0,_promises.writeFile)(filepath,rendered_text);console.log("\n\n",rendered_text,"\n\n")}catch(err){console.error("An unexpected error has occurred: ",err)}};const getRecordsFromPreviousResult=async(horse_id,timestamp)=>{const entrypoint="entries";const url=`${ENDPOINT}/${entrypoint}`;const query=new URLSearchParams({q:`horse_id == "${horse_id}" and timestamp < "${timestamp}"`,key:process.env.API_KEY});const response=await fetch(`${url}?${query}`);const{data}=await response.json();if(!Array.isArray(data)){throw new Error("[getRecordsFromPreviousResult] Invalid value is returned from server."+"Check that the vars `url` and `query` are set to the correct values.")}else{const results=data.filter(isResultData);results.sort((a,b)=>new Date(b.timestamp).getTime()-new Date(a.timestamp).getTime());return{horse_id,results}}};const promise=main();promise.then(()=>{console.log("completed.")}).catch(error=>{console.error(error)});